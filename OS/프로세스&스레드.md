# 프로세스 & 스레드

> ### 프로그램(Program)
- **어떤 작업을 위해 실행할 수 있는 파일**

<br>

> ### 프로세스(Process)
- **실행중인 프로그램**
- 디스크부터 메모리에 적재되어 CPU의 할당을 받은 작업의 단위.
- 운영체제로부터 시스템 자원을 할당받습니다.
- 할당받는 시스템 자원
    - CPU 시간
    - 운영되기 위한 주소 공간
    - Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역.
- 기본적으로 **프로세스마다 최소 1개의 스레드**를 갖습니다.(메인 스레드)
- **프로세스는 각각 별도의 메모리 영역(주소 공간)을 할당**받습니다. [Code, Data, Stack, Heap]
- 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없으며,  
접근을 위해서는 IPC(Inter Process Communication) 통신이 필요합니다.
- Ex) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용.



<br>

> ### 프로세스의 메모리 영역
하나의 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받음.

<img src="https://user-images.githubusercontent.com/68800789/149147435-f2dc1d8b-b3b2-4faf-a673-c89608fcca17.png" width="60%">

- Code 영역:
    - 코드 영역은 **실행할 프로그램의 코드** 및 매크로 상수가 기계어 형태로 저장되는 영역
    - CPU는 코드영역에 저장된 명령어를 하나씩 처리합니다.

- Data 영역:
    - 데이터 영역은 코드에서 선언한 **전역 변수와 정적(static) 변수가 저장**되는 영역
    - 데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸

- Stack 영역:
    - 스택 영역은 **함수 안에서 선언된 지역변수, 매개변수, 리턴값, 등이 저장**되고 함수 호출시 기록하고 종료되면 소멸됩니다.
    - 스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따릅니다.
    - 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우, Stack Overflow(스택오버플로우)에러가 발생합니다.

- Heap 영역:
    - **동적 메모리 할당 공간**으로, 사용이 끝나면 운영체제가 쓸수 있도록 반납해야 합니다.
    - 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적

<br>

> ### 프로세스 제어 블록(Process Control Block, PCB)
- **특정 프로세스에 대한 중요한 정보를 저장**하고 있는 커널 내의 자료구조
- OS는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성합니다.
- 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 합니다.  
이때 **작업의 진행 상황을 모두 PCB에 저장**한다. 그리고 **다시 CPU를 할당받게 되면 PCB에 저장되었던 내용을 불러와 종료되었던 시점부터 다시 작업을 수행**합니다.
- PCB에 저장되는 정보
    - 프로세스 식별자(Process ID, PID): 프로세스 식별 번호
    - 프로세스 상태: new, ready, running, waiting, terminated 등의 상태를 저장
    - 프로그램 카운터(Program Counter, PC): 프로세스가 다음에 실행할 명령어의 주소를 가리킴
    - CPU 레지스터
    - CPU 스케줄링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
    - 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
    - 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
    - 어카운팅 정보: 사용된 CPU 시간, 시간 제한, 계정 번호 등

<br>

> ### 멀티 태스킹
- OS를 통해 CPU가 작업하는데 필요한 **자원(시간)을 프로세스 또는 스레드 간에 나누는 행위**를 말합니다.  
이를 통해 여러 응용 프로그램을 동시에 열고 작업 할 수 있다는 장점이 있습니다.

<br>

> ### 스레드(Thread)
- **프로세스 내에서 실행되는 흐름의 단위**로, 프로세스 내의 주소 공간이나 자원을 공유할 수 있습니다.

<img src="https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png" width="60%">

- 각 스레드는 프로세스 내에서 Stack 영역만 별도로 할당 받고, 부모 프로세스의 Code, Data, Heap 영역은 공유합니다.  
따라서 한 스레드가 프로세스의 자원을 변경하면, 다른 스레드도 그 변경 결과를 즉시 확인할 수 있습니다.

<br>

# 멀티 프로세스 & 멀티 스레드

> ### 멀티 프로세스
- **하나의 응용프로그램을 여러 개의 프로세스로 구성**하여 각 프로세스가 하나의 작업(task)을 처리하도록 하는 것.
- 장점
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않습니다. (안전성)
    - Context Switching의 속도가 빠름
    - 구현이 비교적 간단
- 단점
    1. Context Switching에서의 오버헤드
        - 각 프로세스는 독립된 메모리 영역을 할당받았기 때문에 공유하는 메모리가 없습니다. 따라서 캐시 메모리 초기화 등의 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생할 수 있습니다.
    2. 프로세스 간 어렵고 복잡한 통신 기법 IPC(Inter Process Communication)
        - 독립된 메모리 할당으로 인해 프로세스 간 변수를 공유할 수 없습니다. 따라서 IPC라는 방법을 사용해야 하며, 이는 어렵고 복잡한 통신 방법입니다.

<br>

> ### 멀티 스레드
- **하나의 응용 프로그램을 여러 개의 스레드로 구성**하고 각 스레드가 하나의 작업(task)을 처리하도록 하는 것.
- 윈도우, 리눅스 등 많은 OS들이 멀티 프로세싱을 지원하고 있지만, 멀티 스레딩을 기본으로 하고 있습니다.
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램입니다.

<br>

- 장점
    - 메모리 공간과 시스템 자원 소모가 줄어들게 됩니다.
    - 스레드 간 통신 시, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받으므로 **통신 방법이 간단**합니다.
    - Context Switching 시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠릅니다.
    - 따라서 시스템의 처리량이 향상되고 자원 소모가 줄어들며, 자연스럽게 프로그램의 응답 시간이 단축됩니다.
- 단점
    - 서로 다른 스레드가 Data, Heap 영역 등을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있습니다. 즉, **자원 공유의 문제가 발생합니다.(동기화)**
    - **하나의 스레드에 문제가 생기면 전체 프로세스가 영향**을 받습니다.
    - 주의 깊은 설계가 필요하며, **디버깅이 까다로움**

<br>

> ### Q) 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?
- 프로그램을 여러 개 실행시키는 것보다 **하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적**이기 때문입니다.

<img src="https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png" width="60%">

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.
- Context Switching시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠릅니다.-> **스레드는 Stack 영역만 초기화하면 되기 때문**
- 스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하므로 IPC에 비해 비용이 적고 더 빠르다. -> **스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유**하기 때문입니다.

<br>

> ### Thread-safe
- 멀티 스레드 환경에서 **여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것**을 말합니다.  
이러한 상황을 "Thread-safe 하다"라고 표현합니다.
- Thread-safe 하게 구현하기
    - 이를 위해서는 공유 자원에 접근하는 **임계영역(critical section)을 동기화 기법으로 제어**해줘야 합니다. 이를 '상호배제'라고 한다.
    - 동기화 기법으로는 뮤텍스나 세마포어가 존재
- Reentrant
    - 재진입성이라는 의미로, 어떤 함수가 Reentrant하다는 것은 **여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장**한다는 의미입니다.
    - 정적(전역) 변수를 사용하거나 반환하면 안되고 호출 시 제공된 매개변수만으로 동작해야 합니다.
    - 따라서, Reentrant하다면 Thread-safe하지만 그 역은 성립하지 않습니다.

<br>

> 참고 출처
- [WooVictory](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.md)
- [charlezz](https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37)
- [gmlwjd9405](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
